# [172. 阶乘后的零](https://leetcode-cn.com/problems/factorial-trailing-zeroes/)

>给定一个整数 *n*，返回 *n*! 结果尾数中零的数量。
>
>**示例 1:**
>
>```
>输入: 3
>输出: 0
>解释: 3! = 6, 尾数中没有零。
>```

只有2**5的末尾才有0，所以一个2和一个5可以配一对产生一个0，2的数量肯定比5多，所以只需要计算小于等于n的整数的所有因数中5 的个数即可。如

1. eg5，只有一个5
2. eg10，可以有5和10，其中10=5*2
3. eg17，有5，10，15三个因数里面含5，即17/5=3，
4. eg25，有5，10，15，20，25，其中25/5=5，5/5还有一个因数，共6个
5. eg126,有126/5=25个，25/5=5，还有5个因数可以分解成2个5，5/5=1，还有1个因数可以分解成3个5，所以共有25+5+1=31个
6. 综上可得，需要不断将该n除以5，分别求得可以拆分成一个5的因数个数，可以拆分成2个5的因数的个数，可以拆分成3个5的因数的个数等等，依次相加即可。

~~~java
class Solution {
    public int trailingZeroes(int n) {
        int res=0;
        while(n>=5){
            res+=n/5;
            n/=5;
        }
        return res;
    }
}
~~~