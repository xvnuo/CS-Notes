# Ch8 Main Memory

## 一.背景Background

##### 1.主存概况

程序program必须从磁盘be brought from disk装入内存into memory，并放置在一个进程中placed within a process才能以进程为单位，被CPU解释，执行。

主存main memory和寄存器registers是CPU唯一可以直接访问access directly的存储器。CPU访问寄存器需要一个时钟周期register access in one CPU clock(or less).CPU访问主存可能需要很多个时钟周期many cycles。

缓存cache位于主存和CPU寄存器之间。确保正确的操作需要保护存储器：protection of memory required to ensure correct operation.

##### 2.存储器的继承结构memory hierarchy

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20201227180038744.png" alt="image-20201227180038744" style="zoom:67%;" />

cache位于主存和CPU之间，离CPU越近，容量越小，访问速度越快。

##### 3.基地址寄存器base和limit界限寄存器

基地址寄存器和界限寄存器共同划定了逻辑地址空间logical address space：

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20201227180251823.png" alt="image-20201227180251823" style="zoom: 80%;" />

base寄存器存储起始位置，limit存储空间长度，所以空间范围为base~base+limit

##### 4.指令和数据的地址绑定binding of instructions and data to memory

指令和数据的地址绑定address binding通常发生在三个不同的阶段：

①编译时compile time，如果代码、数据的存放首地址已知，编译阶段即可确定绝对地址。如果首地址变更，则需要重新编译。

②装入时刻load time: 如果代码数据的存放首地址未知，编译阶段即可确定绝对地址，如果首地址变更，则需重新编译。

③执行时刻execution time:如果进程在执行过程中可以从一个内存段移动到另一个内存段from one memory segment to another,则binding延迟直到run time。需要地址映射address maps的硬件支持（例如，base寄存器和limit寄存器）

##### 5.用户程序是如何编译执行的multistep processing of a user program

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20201227181201122.png" alt="image-20201227181201122" style="zoom:80%;" />

编译器compiler负责将用户源程序转换成目标程序，通常为二进制代码binary object code；

链接器linker或链接编辑器linker editor负责将多个目标代码object code连接产生单个可执行程序.exe文件。

加载器Loader：负责加载程序到内存中并准备执行。



##### 6.物理地址physical和逻辑地址空间logical address space的比较

逻辑地址logical address-由generated by CPU生成,也称referred为虚拟地址virtual address，是非物理的各种地址标记

物理地址physical--内存单元看到的地址address seen by memory unit

逻辑地址和物理地址在编译时compile和加载load-time时的地址绑定方案中是相同的；逻辑（虚拟）和物理地址在执行时execution-time地址绑定方案中是不同的。逻辑地址包括符号名，包括编译、汇编、链接、转入操作产生的地址。

##### 7.存储管理单元，MMU，memory-management unit

存储管理单元是将虚拟地址转换成物理地址的硬件设备。

例如一种简单的MMU策略，用户程序user program处理deals with逻辑地址；它从来没有看到真正的物理地址，在用户进程把逻辑地址送往地址总线前，MMU把重定位寄存器relocation register的值加到这个逻辑地址上，转换成物理地址。

基于重定位寄存器的动态重定位relocation的过程：

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20201227182533118.png" alt="image-20201227182533118" style="zoom:80%;" />

就是说，用户程序处理的是逻辑地址，该程序被送入内存时所涉及的每个虚拟地址都要通过重定位寄存器(加上重定位寄存器的值，即虚拟和物理存储器之间的差值)找到真实的物理存储地址，然后再进行运行。

两种方法可以实现运行时不把所有代码都装入内存--动态链接和动态装入。

##### 8.动态装入dynamic loading

进程即将用到的子程序，不被预先装入，只要到真正被调用时才装入内存，这样进程本次运行中没有调用的子程序就不会被装入内存，更有效的利用了内存空间；不需要操作系统特别的支持。

##### 9.动态链接dynamic linking

进程即将用到的代码段，不被预先链接入程序，只有真正被调用时才链接。需要动态链接库的配合。设计一小段代码，称为stub，当真正调用该段代码时，通过stub定位该段代码，或者从外部装入内存。

动态连接提供系统级的支持，操作系统升级时，动态链接库可以直接升级，不需要重新编译应用程序。

##### 10.存储管理的基本思想

存储管理算法的评估和比较要点：硬件支持、性能、碎片化、重定位、交换、内存共享、内存保护等。

## 二.Swapping

##### 1.基本概念

进程可以暂时从内存swaped temporarily中挪到后备存储区backing store，即swap out过程，需要执行时再装入内存，即swap in过程。

后备存储空间需要有的基本特点--足够大的快速磁盘，以容纳所有用户的所有内存的副本copies；后备存储空间一般是一个单独划出的存储空间，要提供直接访问机制。

交换操作结合CPU调度算法，使得及时换出低优先级的进程，让高优先级的进程装入、执行。

##### 2.需要注意的问题

内存交换swapping的基本思想是，把处于等待状态（或在[CPU](https://www.baidu.com/s?wd=CPU&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)调度原则下被剥夺运行权利） 的进程从内存移到辅存，把内存空间腾出来，这一过程又叫换出；把准备好竞争CPU运行的程序从辅存移到内存，这一过程又称为换入。
　　有关交换需要注意以下几个问题：
　　1、交换需要备份存储，通常是快速磁盘。它必须足够大，并且提供对这些内存映像的直接访问。
　　2、为了有效使用[CPU](https://www.baidu.com/s?wd=CPU&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)，需要每个进程的执行时间比交换时间长，而影响交换时间的主要是转移时间transfer time。转移时间与所交换的内存空间成正比。
　　3、如果换出进程，必须确保该进程是完全处于空闲状态。
　　4、交换空间通常作为磁盘的一整块，独立于文件系统，因此使用就可很快。
　　5、交换通常在有许多进程运行且内存空间吃紧时开始启动，而系统负荷降低就暂停。
　　6、普通的交换使用不多，但交换策略的某些变种在许多系统中（如UNIX系统）仍发挥作用。

​		7、**只需要保证就绪队列的进程都在内存就好**，其他进程映像可以被换出。

交换的原理图schematic view：

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20201227185025801.png" alt="image-20201227185025801" style="zoom:80%;" />

## 三.连续内存分配Contiguous Memory Allocation

##### 1.主存基本分区

主存main memory可分为两个分区：①操作系统占一个分区，驻留在主存的低端，终端向量也在低端;②用户进程占另一个分区user processes，通常在主存的高端.

重定位寄存器relocation register可用于保护用户进程不受彼此影响，防止操作系统的代码和数据被篡改。其中包含三种寄存器，base register; limit register; MMU

基址寄存器保存了进程物理地址的首地址；界限寄存器保存了逻辑地址的地址范围，任意一个逻辑地址必须小于界限寄存器的值; MMU能够动态映射每一个地址。

利用base\limit寄存器进行地址映射、地址保护：如果不在范围内，操作系统就会报错，通常情况下用户进程会被终止。

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20201227193332953.png" alt="image-20201227193332953" style="zoom:80%;" />

##### 2.多重分区multiple-partition--连续分配

Hole--有效可分配的内存块；多个长度不等的holes散布在内存的各个区域；当一共进程申请进入主存时，OS选一共hole，其长度足够容纳该进程的映像。它就是分配给该进程的分区partition。

OS维护一些管理信息，包括：①已经分配的分区；②可分配的分区hole。

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20201227193803185.png" alt="image-20201227193803185" style="zoom:80%;" />

如何在一连串holes中找出一共能存储n个单元的hole进行存储？三种算法：

①First-fit：按顺序找，找出第一个足够大能容纳下n个单元的hole即可；

②best-fit：在所有足够大的holes中，找出最小的一个hole，这个算法必须遍历所有hole的列表，之前申请request的分区归还后，留下一堆“最小”holes。

③worst-fit：在所有足够大的hole中，找出最大的一个hole，也要遍历所有holes，之前申请的分区归还后，留下一堆最大的holes.

这样的过程可能会产生内存碎片fragmentation。

##### 3.碎片fragmentation

*碎片分为外部碎片和内部碎片，也是两种看碎片的角度*。

①外部碎片external fragmentation--外部碎片指的是还没有被分配出去（不属于任何进程），但由于太小了无法分配给申请内存空间的新进程的内存空闲区域。

②内部碎片internal fragmentation--内部碎片就是已经被分配出去（能明确指出属于哪个进程）却不能被利用的内存空间；**内部碎片** 是处于 **（操作系统分配的用于装载某一进程的内存）区域内部** ~~或页面内部~~ 的存储块。占有这些区域或页面的进程并不使用这个[存储](http://baike.baidu.com/view/87682.htm)块。而在进程占有这块存储块时，系统无法利用它。直到进程释放它，或进程结束时，系统才有可能利用这个存储块。

可以使用紧缩compaction的方法来减少外部碎片：重新排布内存块，使得所有空闲的内存连续排列，合并成一块大的内存块。前提条件：①代码、数据可以重定位，②重定位可以在运行时操作。

**重定位可以在运行时操作**，除此之外，它的时间花费也是较高的，重定位过程中无法进行其他操作。

## 四.Paging

##### 1.页式内存管理paging--非连续区内存分配

注意一个事实--进程并不要求逻辑地址必须是连续的。

页机制把物理空间等分成长度一致的数据库block，称为帧frames；把逻辑空间等分成长度一致的数据库block，称为页pages，并且与帧长度相等。通常页长，也就是帧的长度是2的幂，取512字节与8192字节之间的数值。

页表page table，建立了页和帧之间的一对一关系。逻辑地址到物理地址的地址翻译：

假设逻辑地址空间logical address space为2^m, 页长(page size页的总大小)为2^n，则页的条目数为2^(n-m)，所以对应m-n位用来存储每一个条目的序号，即页号。CPU提供的逻辑地址addr区分成两个部分：①页号page number, p=addr/P，作为下标，查询页表中的目标单元，该单元包含对应于物理空间的帧的基地址。②页内偏移量page offset, d=addr%P，该地址对应帧的偏移位置。

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20201227200436648.png" alt="image-20201227200436648" style="zoom:80%;" />

其中page number是页表中能够存储的页的条目数，对应有2^(m-n)个条目，所以有m-n位，page offset,页的大小是2^n，对应n位找出在页内的偏移。页偏移=帧偏移，页大小=帧大小，但是page  number不一定。

地址翻译过程：

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20201227201356114.png" alt="image-20201227201356114" style="zoom:80%;" />

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20201227201509867.png" alt="image-20201227201509867" style="zoom:80%;" />

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20201227201540430.png" alt="image-20201227201540430" style="zoom:80%;" />

上图page table中左边存的是页号，右边存的是帧号。

页式内存管理中，操作系统主要负责管理所有的空闲帧。若进程需要n页逻辑空间，OS分配n个空闲帧给他，装入代码和数据。OS分配页表需要的物理空间，布置好页表。页式内存管理存在internal内部碎片的问题，因为所有的空闲页都是一页一页分配给进程的，进程需要的未必有那么大，所以会存在页内空间不能使用的内部碎片化问题。

##### 2.如何实现页表

页表必须驻留内存。页表基地址寄存器Page-table base register(PTBR)指向页表的首地址；页表长度寄存器page-table length register(PRLR)表示页表占用的空间长度。每个进程都有一个页表，否则无法区分内存空间属于哪些进程。

访问一个数据或地址，需要两次内存访问：1次访问页表，一次访问数据或地址本身，开销较大，可借助translation look-aside buffers，即TLBs解决两次访问问题。

TLB也称作关联存储器associative memory，支持并行搜索。用于对(p,d)的地址翻译，如果p恰好在TLB(hit)，直接从TLB得到帧号，否则(fail)，从内存页表中取得帧号。有TLB的情况：

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20201227202923851.png" alt="image-20201227202923851" style="zoom:80%;" />

##### 3.有效访问时间effective access time

设TLB的查询时间为ε单位时间，假设内存访问周期为1微妙，命中率hit ratio为成功在TLB中取得页号的百分率，命中率与TLB的单元总数有关，设命中率为α，有效访问时间EAT= (1 + ε) α + (2 + ε)(1 – α)= 2 + ε – α。

①访问一次TLB且命中用时(1+ε)--访问TLB的时间+找到帧号进入内存访问该帧的时间

②访问TLB且没有命中用时为(2+ε)--访问TLB的时间+通过页表两次访问内存的时间

##### 4.内存保护

在进程页表的每个页表项中，为每个页设置了一个保护位valid-invalid bit,页称有效位。

有效v--表示该页面在进程的逻辑地址空间范围内，因此是合法页面; 无效i--表示该页面不在进程的逻辑地址空间范围内。

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20201227204139195.png" alt="image-20201227204139195" style="zoom:80%;" />

##### 5.共享页面shared pages

共享代码shared code：只读代码只需要一份，供若干进程共享，如(文本编辑器，编译器，窗口系统等)；对所有进程来说，共享代码必须位于逻辑地址空间的相同位置。

进程自有代码和数据private code and date：进程各自拥有一份，为自有代码private code 、private数据data分配的页面pages可以分布在进程逻辑地址空间的任意位置。

如，一共模块有多个进程调用，就可以将该代码放在共享的页上

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20201227204603878.png" alt="image-20201227204603878" style="zoom:80%;" />



## 五.Structure of the Page Table

##### 1.层次页表hierarchy paging

将页表的逻辑地址拆分成多张页表，如二级页表，三级页表。

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20201227205010822.png" alt="image-20201227205010822" style="zoom:80%;" />

实例--二级页表two_level paging

逻辑地址(32位CPU，页长4kb=2^12 bytes)分隔成两部分：页号20位，页内偏移量12位

页表被进一步分页，其页号被分割成两部分：页号的页号10位，页号的页内偏移量10位。其中p1是外层页表的下标，p2是外层页表内部的偏移。

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20201227205053566.png" alt="image-20201227205053566" style="zoom:80%;" />

二级页表策略的地址翻译：

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20201227210034816.png" alt="image-20201227210034816" style="zoom:80%;" />

三级页表机制：

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20201227210135822.png" alt="image-20201227210135822" style="zoom:67%;" />

##### 2.哈希页表hash page table

多见于地址空间大于32位的CPU，虚拟页号警告哈希函数转换后，指向页表中某个页表项；哈希函数值相同的页号，指向同一个页表条目，他们在呢个页表条目下组成一个链表。地址翻译时，由虚拟页号哈希后锁定对应链表，搜索与虚拟页号的匹配项。如果找到了匹配，则找到了虚拟页号对应的物理帧。

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20201227210424738.png" alt="image-20201227210424738" style="zoom:67%;" />

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20201227210439672.png" alt="image-20201227210439672" style="zoom:80%;" />

##### 3.反向页表inverted page table

每个物理页帧，对应inverted page table的一共表项。对于每个表项，他表示的物理页帧存储了某个进程的一个逻辑也，表项内容包含该进程的id,页号。对比传统页表，该方法的页表空间大幅度减少，利用哈希表使得查页表操作能一次命中，或者耗费较少的查找次数。

如图，他使用进程的PID和页号作为key进行搜索，得到的下标i和偏移量组合对帧进行访问。**通过使用反向页表，我们可以使得整个操作系统共用一个页表，从而节省了页表空间**，但是相应的，查询的时候比较麻烦。当然也可以借助哈希技术改造，实现一次命中。

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20201227210744566.png" alt="image-20201227210744566" style="zoom:80%;" />

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20201227212309212.png" alt="image-20201227212309212" style="zoom:80%;" />

## 六.段式存储管理Segmentation

##### 1.概念

这是一种顺应用户视角的内存管理机制，程序一定是由许多段代码、数据组成，段segmentation是自然的逻辑单元。用户视角看程序：

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20201227212613481.png" alt="image-20201227212613481" style="zoom:80%;" />

段的逻辑视角：

![image-20201227212710914](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20201227212710914.png)

##### 2.机制

一个逻辑地址划分成两部分<段号segment-number，段内偏移量offset>；段表segment table--以段号为索引下标，将其映射到二维的物理地址；段表项内容包括①基地址base--记录该段在物理内存的首地址；②界限limit--记录该段的长度。

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20201227213505671.png" alt="image-20201227213505671" style="zoom:80%;" />

段式管理中使用段表而不是页表。段表基地址寄存器segment-table base register， STBR，指向内存中段表的首地址；段表长度寄存器segment-table length register，STLR，记录程序总段数，也表示段表项的总数。合法的段号s必须满足s<STLR

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20201227213354775.png" alt="image-20201227213354775" style="zoom:80%;" />

##### 3.内存保护

每个段表项都有保护位:①有效位(1位)=0 => 无效段；②特权位privileges(2位)read/write/execute，可设置特权位来控制进程对内存的读写和执行。

##### 4.内存分配

段的长度可变，区别于页，内存分配面临dynamic storage-allocaion动态存储分配问题：first fit/ best fit/ worst fit等

存在外部碎片问题，因为段长度可变，所以不存在内部碎片化问题。

重定位--可以动态重定位，借助段表实现；内存共享--以段为最小单位，支持进程间代码共享，进程必须给共享段以相同的段号。

##### 5.段内还可分页segmnetation on paging

逻辑地址由段组成，每段由页组成。将段地址翻译成物理地址：

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20201227214203198.png" alt="image-20201227214203198" style="zoom:80%;" />

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20201227214240227.png" alt="image-20201227214240227" style="zoom:80%;" />

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20201227214312894.png" alt="image-20201227214312894" style="zoom:80%;" />

i386的段式管理：采用段描述符的管理，维护一个段描述符表。

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20201227214433857.png" alt="image-20201227214433857" style="zoom:80%;" />

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20201227214537282.png" alt="image-20201227214537282" style="zoom:80%;" />



